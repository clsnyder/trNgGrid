/// <reference path="../external/typings/angularjs/angular.d.ts"/>
"use strict";
module TrNgGrid{
    export enum SelectionMode {
        None,
        SingleRow,
        MultiRow,
        MultiRowWithKeyModifiers
    }

    export declare var defaultPagerMinifiedPageCountThreshold: number;
    export declare var defaultColumnOptions: IGridColumnOptions;
    export declare var translations: { [language: string]: { [textId: string]: string } };
    export declare var translationDateFormat: string;

    export declare var columnSortDirectiveAttribute: string;
    export declare var columnFilterDirectiveAttribute: string;
    export declare var globalFilterDirectiveAttribute: string;
    export declare var pagerDirectiveAttribute: string;

    export declare var dataPagingFilter: string;
    export declare var dataFormattingFilter: string;
    export declare var translateFilter: string;

    export declare var debugMode: boolean;

    export declare var tableCssClass: string;
    export declare var cellCssClass: string;
    export declare var headerCellCssClass: string;
    export declare var bodyCellCssClass: string;
    export declare var columnTitleCssClass: string;
    export declare var columnSortCssClass: string;
    export declare var columnFilterCssClass: string;
    export declare var columnFilterInputWrapperCssClass: string;
    export declare var columnSortActiveCssClass: string;
    export declare var columnSortInactiveCssClass: string; 
    export declare var columnSortReverseOrderCssClass: string;
    export declare var columnSortNormalOrderCssClass: string;
    export declare var rowSelectedCssClass: string; 
    export declare var footerCssClass: string;

    export declare var cellHeaderTemplateId:string;
    export declare var cellBodyTemplateId: string;
    export declare var columnFilterTemplateId: string;
    export declare var columnSortTemplateId:string;
    export declare var cellFooterTemplateId: string;
    export declare var footerPagerTemplateId: string;
    export declare var footerGlobalFilterTemplateId: string;

    // it's important to assign all the default column options, so we can match them with the column attributes in the markup
    defaultColumnOptions = {
        cellWidth: null,
        cellHeight: null,
        displayAlign: null,
        displayFormat: null,
        displayName: null,
        filter: null,
        enableFiltering: null,
        enableSorting:null
    };

    translations = {};

    debugMode = false;

    var templatesConfigured = false;
    var tableDirective = "trNgGrid";
    dataPagingFilter = tableDirective + "DataPagingFilter";
    translateFilter = tableDirective + "TranslateFilter";
    translationDateFormat = tableDirective + "DateFormat";
    dataFormattingFilter = tableDirective + "DataFormatFilter";

    //var headerDirective="trNgGridHeader";
    //var headerDirectiveAttribute = "tr-ng-grid-header";

    var headerDirective = "trNgGridHeader";
    var headerDirectiveAttribute = "tr-ng-grid-header";

    var footerDirective = "trNgGridFooter";
    var footerDirectiveAttribute = "tr-ng-grid-footer";

    var bodyDirective="trNgGridBody";
    var bodyDirectiveAttribute = "tr-ng-grid-body";

    var fieldNameAttribute = "field-name";
    var isCustomizedAttribute = "is-customized";
    //var isAutoGeneratedAttribute = "is-auto-generated";

    var cellFooterDirective="trNgGridFooterCell";
    var cellFooterDirectiveAttribute = "tr-ng-grid-footer-cell";
    var cellFooterAutoGeneratedDirective = "trNgGridFooterCellAutoGenerated";
    var cellFooterAutoGeneratedDirectiveAttribute = "tr-ng-grid-footer-cell-auto-generated";
    var cellFooterTemplateDirective = "trNgGridFooterCellTemplate";
    var cellFooterTemplateDirectiveAttribute = "tr-ng-grid-footer-cell-template";
    cellFooterTemplateId = cellFooterTemplateDirective + ".html";

    var globalFilterDirective="trNgGridGlobalFilter";
    globalFilterDirectiveAttribute = "tr-ng-grid-global-filter";
    footerGlobalFilterTemplateId = globalFilterDirective + ".html";

    var pagerDirective="trNgGridPager";
    pagerDirectiveAttribute = "tr-ng-grid-pager";
    footerPagerTemplateId = pagerDirective + ".html";

    var cellHeaderDirective="trNgGridHeaderCell";
    var cellHeaderDirectiveAttribute = "tr-ng-grid-header-cell";
    var cellHeaderAutoGeneratedDirective = "trNgGridHeaderCellAutoGenerated";
    var cellHeaderAutoGeneratedDirectiveAttribute = "tr-ng-grid-header-cell-auto-generated";
    var cellHeaderTemplateDirective = "trNgGridHeaderCellTemplate";
    var cellHeaderTemplateDirectiveAttribute = "tr-ng-grid-header-cell-template";

    //var cellHeaderSourceTemplateDirective = "trNgGridHeaderCellSource";
    //var cellHeaderSourceTemplateDirectiveAttribute = "tr-ng-grid-header-cell-source";

    cellHeaderTemplateId = cellHeaderTemplateDirective + ".html";

    var cellBodyDirective = "trNgGridBodyCell";
    var cellBodyDirectiveAttribute = "tr-ng-grid-body-cell";
    var cellBodyAutoGeneratedDirective = "trNgGridBodyCellAutoGenerated";
    var cellBodyAutoGeneratedDirectiveAttribute = "tr-ng-grid-body-cell-auto-generated";
    var cellBodyTemplateDirective = "trNgGridBodyCellTemplate";
    var cellBodyTemplateDirectiveAttribute = "tr-ng-grid-body-cell-template";
    cellBodyTemplateId = cellBodyTemplateDirective + ".html";

    //var cellBodySourceTemplateDirective = "trNgGridBodyCellSource";
    //var cellBodySourceTemplateDirectiveAttribute = "tr-ng-grid-body-cell-source";

    var columnSortDirective="trNgGridColumnSort";
    columnSortDirectiveAttribute="tr-ng-grid-column-sort";
    columnSortTemplateId = columnSortDirective + ".html";

    var columnFilterDirective="trNgGridColumnFilter";
    columnFilterDirectiveAttribute = "tr-ng-grid-column-filter";
    columnFilterTemplateId = columnFilterDirective+".html";

    //var rowPageItemIndexAttribute="tr-ng-grid-row-page-item-index";

    enum ColumnDefinitionSource {
        Header,
        Body
    }

    interface IGridColumn {
        fieldName: string;
        columnDefinitionId?: number;
    }

    export interface IGridColumnOptions {
        displayName?: string;
        displayAlign?: string;
        displayFormat?: string;
        enableSorting?: boolean;
        enableFiltering?: boolean;
        cellWidth?: string;
        cellHeight?: string;
        filter?: string;
    }

    interface IGridColumnDefinition extends IGridColumnOptions, IGridColumn {
        displayFieldName?: string;
        isCustomized: { [source: number]: boolean };
        definitionSource: { [source: number]: boolean };
        ephemeralPlaceholder:ng.IAugmentedJQuery;
    }

    interface IGridDisplayItem {
        $$_gridItem: any;
    }

    interface IGridOptions{
        items: Array<any>;
        fields: Array<string>;
        selectedItems: Array<any>;
        filterBy: string;
        filterByFields: Object;
        orderBy: string;
        orderByReverse: boolean;
        pageItems: number;
        currentPage: number;
        totalItems: number;
        enableFiltering: boolean;
        enableSorting: boolean;
        selectionMode: string;
        onDataRequired: (gridOptions: IGridOptions) => void;
        onDataRequiredDelay: number;
        locale: string;
        immediateDataRetrieval: boolean;
        gridColumnDefs: Array<IGridColumnDefinition>;
    }

    interface IGridScope extends ng.IScope{
        TrNgGrid: any; // useful for binding to static vars on the TrNgGrid type
        gridOptions: IGridOptions;
        displayedGridColumnDefs: Array<IGridColumnDefinition>;
        filterByDisplayFields: any;
        filteredItems: Array<IGridDisplayItem>;
        requiresReFilteringTrigger: boolean;
        formattedItems: Array<IGridDisplayItem>;
        speedUpAsyncDataRetrieval: ($event?: ng.IAngularEvent) => void;
    }

    interface IGridHeaderScope extends IGridScope {
    }

    interface IGridColumnScope extends IGridScope{
        columnOptions: IGridColumnDefinition;
    }

    interface IGridHeaderColumnSettingsScope extends IGridScope, IGridColumnOptions, IGridColumn {
        isCustomized: boolean;
    }

    interface IGridHeaderColumnScope extends IGridColumnScope {
        columnTitle: string;
        toggleSorting: (propertyName: string) => void;
    }

    interface IGridBodyScope extends IGridScope {
        toggleItemSelection: (item: any, $event: ng.IAngularEvent) => void;
    }

    interface IGridBodyColumnScope extends IGridColumnScope{
        gridItem:any;
        gridDisplayItem: IGridDisplayItem;
    }

    interface IGridFooterScope extends IGridScope{
        isCustomized?: boolean;
        isPaged: boolean;
        extendedControlsActive: boolean;
        totalItemsCount:number;
        startItemIndex: number;
        lastPageIndex: number;
        pageIndexes: Array<number>;
        endItemIndex:number;
        pageCanGoBack:boolean;
        pageCanGoForward: boolean;
        pageSelectionActive: boolean;
        switchPageSelection: ($event: ng.IAngularEvent, pageSelectionActive: boolean) => void;
        navigateToPage:(pageIndex:number)=>void;
    }

    var findChildByTagName = (parent: ng.IAugmentedJQuery, childTag: string): ng.IAugmentedJQuery=> {
        childTag = childTag.toUpperCase();
        var children = parent.children();
        for (var childIndex = 0; childIndex < children.length; childIndex++) {
            var childElement = children[childIndex];
            if (childElement.tagName == childTag) {
                return angular.element(childElement);
            }
        }

        return null;
    }

    var findChildrenByTagName = (parent: ng.IAugmentedJQuery, childTag: string): Array<ng.IAugmentedJQuery> => {
        childTag = childTag.toUpperCase();
        var retChildren = [];
        var children = parent.children();
        for (var childIndex = 0; childIndex < children.length; childIndex++) {
            var childElement = children[childIndex];
            if (childElement.tagName == childTag) {
                retChildren.push(angular.element(childElement));
            }
        }

        return retChildren;
    };

    /**
     * Combines two sets of cell infos. The first set will take precedence in the checks but the combined items will contain items from the second set if they match.
     */
    var combineGridCellInfos = <T extends IGridColumn>(
        firstSet: Array<T>,
        secondSet: Array<T>,
        addExtraFieldItemsSecondSet?: boolean,
        addExtraNonFieldItemsSecondSet?:boolean): Array<T> => {

        var combinedSet: Array<T> = [];
        var secondTempSet = secondSet.slice(0);
        angular.forEach(firstSet, (firstSetColumn:T) => {
            // find a correspondence in the second set
            var foundSecondSetColumn: T = null;
            for (var secondSetColumnIndex = 0; !foundSecondSetColumn && secondSetColumnIndex < secondTempSet.length; secondSetColumnIndex++) {
                foundSecondSetColumn = secondTempSet[secondSetColumnIndex];
                if (foundSecondSetColumn.fieldName === firstSetColumn.fieldName) {
                    secondTempSet.splice(secondSetColumnIndex, 1);
                }
                else {
                    foundSecondSetColumn = null;
                }
            }

            if (foundSecondSetColumn) {
                combinedSet.push(foundSecondSetColumn);
            }
            else{
                combinedSet.push(firstSetColumn);
            }
        });

        // add the remaining items from the second set in the combined set
        if (addExtraFieldItemsSecondSet || addExtraNonFieldItemsSecondSet) {
            angular.forEach(secondTempSet, (secondSetColumn: T) => {
                if ((addExtraFieldItemsSecondSet && secondSetColumn.fieldName) || (addExtraNonFieldItemsSecondSet && !secondSetColumn.fieldName)) {
                    combinedSet.push(secondSetColumn);
                }
            });
        }

        return combinedSet;
    };

    class GridController{
        //private gridScope: IGridScope;
        private gridOptions: IGridOptions;
        private gridColumnId: number = 0;
        //private templatedHeader: TemplatedSection;
        //private templatedBody: TemplatedSection;
        //private templatedFooter: TemplatedSection;
        //private gridElement:ng.IAugmentedJQuery;
        private columnDefsFieldsWatcherDeregistrationFct: Function;
        private dataRequestPromise: ng.IPromise<any>;
        private itemColumnDefWatcherDeregFct: Function;

        constructor(
            private $compile: ng.ICompileService,
            private $parse: ng.IParseService,
            private $timeout: ng.ITimeoutService,
            $templateCache: ng.ITemplateCacheService) {

            if (!templatesConfigured) {
                configureTemplates($templateCache);
                templatesConfigured = true;
            }
        }

        public setupScope($isolatedScope: ng.IScope, gridScope:IGridScope, $attrs: ng.IAttributes): IGridScope{
            // initialise the options
            this.gridOptions = <IGridOptions>{
                immediateDataRetrieval: true,
                items: [],
                fields: null,
                locale: "en",
                selectedItems:[],
                filterBy:null,
                filterByFields:{},
                orderBy:null,
                orderByReverse:false,
                pageItems:null,
                currentPage:0,
                totalItems:null,
                enableFiltering:true,
                enableSorting:true,
                selectionMode:SelectionMode[SelectionMode.MultiRow],
                onDataRequiredDelay:1000
            };
            this.gridOptions.onDataRequired = $attrs["onDataRequired"]?$isolatedScope["onDataRequired"]:null;
            this.gridOptions.gridColumnDefs = [];
            //internalScope[scopeOptionsIdentifier] = this.gridOptions;


            //link the outer scope with the internal one
            gridScope.gridOptions = this.gridOptions;
            gridScope.TrNgGrid = TrNgGrid;
            this.linkScope(gridScope, $isolatedScope, "gridOptions", $attrs);

            //set up watchers for some of the special attributes we support
            if (this.gridOptions.onDataRequired) {
                var retrieveDataCallback = () => {
                    this.dataRequestPromise = null;
                    this.gridOptions.immediateDataRetrieval = false;
                    this.gridOptions.onDataRequired(this.gridOptions);
                };

                gridScope.$watchCollection("[gridOptions.filterBy, " +
                    "gridOptions.filterByFields, " +
                    "gridOptions.orderBy, " +
                    "gridOptions.orderByReverse, " +
                    "gridOptions.pageItems, " +
                    "gridOptions.currentPage]",()=>{

                        if(this.dataRequestPromise){
                            this.$timeout.cancel(this.dataRequestPromise);
                            this.dataRequestPromise = null;
                        }

                        if (this.gridOptions.immediateDataRetrieval) {
                            retrieveDataCallback();
                        }
                        else {
                            this.dataRequestPromise = this.$timeout(() => {
                                retrieveDataCallback();
                            }, this.gridOptions.onDataRequiredDelay, true);
                        }
                });

                gridScope.$watch("gridOptions.immediateDataRetrieval", (newValue: boolean) => {
                    if (newValue && this.dataRequestPromise) {
                        this.$timeout.cancel(this.dataRequestPromise);
                        retrieveDataCallback();
                    }
                });
            }

            // the new settings
            gridScope.$watch("gridOptions.selectionMode", (newValue: any, oldValue: SelectionMode) => {
                if (newValue !== oldValue) {
                    // when this value is changing we need to handle the selectedItems
                    switch (newValue) {
                        case SelectionMode[SelectionMode.None]:
                            this.gridOptions.selectedItems.splice(0);
                            break;
                        case SelectionMode[SelectionMode.SingleRow]:
                            if (this.gridOptions.selectedItems.length > 1) {
                                this.gridOptions.selectedItems.splice(1);
                            }
                            break;
                    }
                }
            });

            return gridScope;
        }

        speedUpAsyncDataRetrieval($event?: ng.IAngularEvent) {
            if (!$event || $event.keyCode == 13) {
                this.gridOptions.immediateDataRetrieval = true;
            }
        }

        ////setColumnOptions(columnIndex: number, columnOptions: IGridColumnOptions): void {
        ////    var originalOptions = this.gridOptions.gridColumnDefs[columnIndex];
        ////    if (!originalOptions) {
        ////        throw "Invalid grid column options found for column index " + columnIndex + ". Please report this error."
        ////    }

        ////    // copy a couple of options onto the incoming set of options
        ////    columnOptions = angular.extend(columnOptions, originalOptions);

        ////    // replace the original options 
        ////    this.gridOptions.gridColumnDefs[columnIndex] = columnOptions;            
        ////}

        toggleSorting(propertyName: string) {
            if(this.gridOptions.orderBy!=propertyName){
                // the column has changed
                this.gridOptions.orderBy = propertyName;
            }
            else{
                // the sort direction has changed
                this.gridOptions.orderByReverse=!this.gridOptions.orderByReverse;
            }

            this.speedUpAsyncDataRetrieval();
        }

        getFormattedFieldName(fieldName: string) {
            return fieldName.replace(/[\.\[\]]/g, "_");
        }

        setFilter(fieldName: string, filter: string) {
            if(!filter){
                delete (this.gridOptions.filterByFields[fieldName]);
            }
            else{
                this.gridOptions.filterByFields[fieldName] = filter;
            }

            // in order for someone to successfully listen to changes made to this object, we need to replace it
            this.gridOptions.filterByFields = angular.extend({}, this.gridOptions.filterByFields);
        }

        validateColumnDefinitions(gridScope: IGridScope) {
            gridScope.displayedGridColumnDefs = [];

            for (var columnDefIndex = 0; columnDefIndex < this.gridOptions.gridColumnDefs.length; columnDefIndex++) {
                var columnDef = this.gridOptions.gridColumnDefs[columnDefIndex];
                if (columnDef.fieldName) {
                    // a field name was set, check against the fields, if set

                }
                else {
                    // a custom field, always add it
                    gridScope.displayedGridColumnDefs.push(columnDef);
                }
            }
        }

        initializeColumnDefinitions(gridScope: IGridScope) {
            if (this.columnDefsFieldsWatcherDeregistrationFct) {
                this.columnDefsFieldsWatcherDeregistrationFct();
                this.columnDefsFieldsWatcherDeregistrationFct = null;
            }

            // set up watchers for auto field definitions extraction
            this.columnDefsFieldsWatcherDeregistrationFct = gridScope.$watch("gridOptions.items.length", (newItemsLength: number) => {
                if (newItemsLength) {
                    // extract the field names
                    for (var propName in this.gridOptions.items[0]) {
                        // exclude the library properties
                        if (!propName.match(/^[_\$]/g)) {
                            this.registerColumn(propName, ColumnDefinitionSource.Header);
                        }
                    }
                }
            });

            this.gridOptions.gridColumnDefs = [];
            gridScope.displayedGridColumnDefs = [];
            gridScope.$watchCollection("gridOptions.gridColumnDefs", (newGridColumnDefs: Array<IGridColumnDefinition>) => {
                // TODO: not enough!!!!
                if (newGridColumnDefs.length > 0 && this.columnDefsFieldsWatcherDeregistrationFct) {
                    this.columnDefsFieldsWatcherDeregistrationFct();
                    this.columnDefsFieldsWatcherDeregistrationFct = null;
                }

                gridScope.displayedGridColumnDefs.splice(0);
                if (newGridColumnDefs) {
                    debugger;
                    angular.forEach(newGridColumnDefs, (gridColumnDefinition: IGridColumnDefinition) => {
                        for (var sourceType in gridColumnDefinition.definitionSource) {
                            // any active source will cause the grid def to be used
                            gridScope.displayedGridColumnDefs.push(gridColumnDefinition);
                            break;
                        }
                    });
                }
            });
        }

        registerColumn(fieldName:string, sourceType: ColumnDefinitionSource, isCustomized?:boolean, columnOptions?:IGridColumnOptions):IGridColumnDefinition {
            // find the column definition first
            var columnDefOptions: IGridColumnDefinition;
            var columnDefIndex: number;
            for (columnDefIndex = 0; columnDefIndex < this.gridOptions.gridColumnDefs.length && this.gridOptions.gridColumnDefs[columnDefIndex].fieldName !== fieldName; columnDefIndex++);
            if (columnDefIndex >= this.gridOptions.gridColumnDefs.length) {
                // it's new, add it, but persist the column options by ref
                columnDefOptions = <IGridColumnDefinition>angular.extend(columnOptions || {}, {
                    fieldName: fieldName,
                    definitionSource: {},
                    columnIndex: {},
                    isCustomized: {},
                    columnDefinitionId: (this.gridColumnId++)
                });
                this.gridOptions.gridColumnDefs.push(columnDefOptions);
            }
            else {
                columnDefOptions = this.gridOptions.gridColumnDefs[columnDefIndex];

                if (columnOptions) {
                    // override the column options by ref
                    columnDefOptions = angular.extend(columnOptions, columnDefOptions);
                    this.gridOptions.gridColumnDefs[columnDefIndex] = columnDefOptions;
                }
            }

            columnDefOptions.definitionSource[sourceType] = true;
            //columnDefOptions.columnIndex[sourceType] = columnDefIndex;
            if (typeof (isCustomized) !== "undefined") {
                columnDefOptions.isCustomized[sourceType] = isCustomized;
            }

            return columnDefOptions;
        }

        unregisterColumn(fieldName: string, sourceType: ColumnDefinitionSource) {
            // find the column definition first
            var columnDefOptions: IGridColumnDefinition;
            var columnDefIndex: number;
            for (columnDefIndex = 0; columnDefIndex < this.gridOptions.gridColumnDefs.length && this.gridOptions.gridColumnDefs[columnDefIndex].fieldName !== fieldName; columnDefIndex++);
            if (columnDefIndex < this.gridOptions.gridColumnDefs.length) {
                columnDefOptions = this.gridOptions.gridColumnDefs[columnDefIndex];
                delete columnDefOptions.definitionSource[sourceType];
                delete columnDefOptions.isCustomized[sourceType];
            }
        }

        ////setupColumn(fieldName:string, sourceType:ColumnDefinitionSource, isCustomized:boolean, gridOptions?: IGridColumnOptions) {
        ////    var columnDefinition = this.registerColumn(sourceType, { fieldName: fieldName });
        ////    for (var columnDefIndex = 0; columnDefIndex < this.gridOptions.gridColumnDefs.length && columnDefinition !== this.gridOptions.gridColumnDefs[columnDefIndex]; columnDefIndex++);

        ////    if (columnDefIndex < this.gridOptions.gridColumnDefs.length) {
        ////        this.gridOptions.gridColumnDefs[columnDefIndex] = angular.extend(gridOptions, this.gridOptions.gridColumnDefs[columnDefIndex]);
        ////    }
        ////    else {
        ////        throw new Error("Unable to apply the settings for the field '" + fieldName + "'. The field was not registered.");
        ////    }
        ////}

        findColumnOptionsByFieldName(fieldName: string): IGridColumnDefinition {
            var columnDefIndex: number;
            for (columnDefIndex = 0; columnDefIndex < this.gridOptions.gridColumnDefs.length && this.gridOptions.gridColumnDefs[columnDefIndex].fieldName !== fieldName; columnDefIndex++);
            if (columnDefIndex < this.gridOptions.gridColumnDefs.length) {
                return this.gridOptions.gridColumnDefs[columnDefIndex];
            }

            return null;
        }

        toggleItemSelection(filteredItems: Array<IGridDisplayItem>, item: any, $event: ng.IAngularEvent) {
            if (this.gridOptions.selectionMode === SelectionMode[SelectionMode.None])
                return;

            switch (this.gridOptions.selectionMode) {
                case SelectionMode[SelectionMode.MultiRowWithKeyModifiers]:
                    if (!$event.ctrlKey && !$event.shiftKey && !$event.metaKey) {
                        // if neither key modifiers are pressed, clear the selection and start fresh
                        var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                        this.gridOptions.selectedItems.splice(0);
                        if (itemIndex < 0) {
                            this.gridOptions.selectedItems.push(item);
                        }
                    }
                    else {
                        if ($event.ctrlKey || $event.metaKey) {
                            // the ctrl key deselects or selects the item
                            var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                            if (itemIndex >= 0) {
                                this.gridOptions.selectedItems.splice(itemIndex, 1);
                            }
                            else {
                                this.gridOptions.selectedItems.push(item);
                            }
                        }
                        else if ($event.shiftKey) {
                            // clear undesired selections, if the styles are not applied
                            if (document.selection && document.selection.empty) {
                                document.selection.empty();
                            } else if (window.getSelection) {
                                var sel = window.getSelection();
                                sel.removeAllRanges();
                            }

                            // the shift key will always select items from the last selected item
                            var firstItemIndex:number;
                            var lastSelectedItem = this.gridOptions.selectedItems[this.gridOptions.selectedItems.length - 1];
                            for (firstItemIndex = 0; firstItemIndex < filteredItems.length && filteredItems[firstItemIndex].$$_gridItem !== lastSelectedItem; firstItemIndex++);
                            if (firstItemIndex >= filteredItems.length) {
                                firstItemIndex = 0;
                            }

                            var lastItemIndex: number;
                            for (lastItemIndex = 0; lastItemIndex < filteredItems.length && filteredItems[lastItemIndex].$$_gridItem !== item; lastItemIndex++);
                            if (lastItemIndex >= filteredItems.length) {
                                // this is an error
                                throw "Invalid selection on a key modifier selection mode";
                            }
                            if (lastItemIndex < firstItemIndex) {
                                var tempIndex = firstItemIndex;
                                firstItemIndex = lastItemIndex;
                                lastItemIndex = tempIndex;
                            }

                            // now select everything in between. remember that a shift modifier can never be used for de-selecting items
                            for (var currentItemIndex = firstItemIndex; currentItemIndex <= lastItemIndex; currentItemIndex++) {
                                var currentItem = filteredItems[currentItemIndex].$$_gridItem;
                                if(this.gridOptions.selectedItems.indexOf(currentItem) < 0){
                                    this.gridOptions.selectedItems.push(currentItem);
                                }
                            }
                        }
                    }
                    break;
                case SelectionMode[SelectionMode.SingleRow]:
                    var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                    this.gridOptions.selectedItems.splice(0);
                    if (itemIndex < 0) {
                        this.gridOptions.selectedItems.push(item);
                    }
                    break;
                case SelectionMode[SelectionMode.MultiRow]:
                    var itemIndex = this.gridOptions.selectedItems.indexOf(item);
                    if (itemIndex >= 0) {
                        this.gridOptions.selectedItems.splice(itemIndex, 1);
                    }
                    else {
                        this.gridOptions.selectedItems.push(item);
                    }
                    break;
            }
        }

        computeFormattedItems(scope: IGridScope) {
            var input = scope.gridOptions.items || <Array<any>>[];
            debugMode && log("formatting items of length " + input.length);
            var formattedItems: Array<IGridDisplayItem> = scope.formattedItems = (scope.formattedItems || <Array<IGridDisplayItem>>[]);
            if (scope.gridOptions.onDataRequired) {
                scope.filteredItems = formattedItems;
            }
            else {
                scope.requiresReFilteringTrigger = !scope.requiresReFilteringTrigger;
            }
            var gridColumnDefs = this.gridOptions.gridColumnDefs;
            for (var inputIndex = 0; inputIndex < input.length; inputIndex++) {
                var inputItem = input[inputIndex];
                var outputItem: IGridDisplayItem;

                // check for removed items, try to keep the item instances intact
                while (formattedItems.length > input.length && (outputItem = formattedItems[inputIndex]).$$_gridItem !== inputItem) {
                    formattedItems.splice(inputIndex, 1);
                }

                if (inputIndex < formattedItems.length) {
                    outputItem = formattedItems[inputIndex];
                    if (outputItem.$$_gridItem !== inputItem) {
                        outputItem = { $$_gridItem: inputItem };
                        formattedItems[inputIndex] = outputItem;
                    }
                }
                else {
                    outputItem = { $$_gridItem: inputItem };
                    formattedItems.push(outputItem);
                }
                for (var gridColumnDefIndex = 0; gridColumnDefIndex < gridColumnDefs.length; gridColumnDefIndex++) {
                    try {
                        var gridColumnDef = gridColumnDefs[gridColumnDefIndex];
                        var fieldName = gridColumnDef.fieldName;
                        if (fieldName) {
                            var displayFormat = gridColumnDef.displayFormat;
                            if (displayFormat) {
                                if (displayFormat[0] != "." && displayFormat[0] != "|") {
                                    // angular filter
                                    displayFormat = " | " + displayFormat;
                                }

                                // apply the format
                                outputItem[gridColumnDef.displayFieldName] = scope.$eval("gridOptions.items[" + inputIndex + "]." + fieldName + displayFormat);
                            }
                            else {
                                outputItem[gridColumnDef.displayFieldName] = eval("inputItem." + fieldName);
                            }
                        }
                    }
                    catch (ex) {
                        debugMode && log("Field evaluation failed for <" + fieldName + "> with error " + ex);
                    }
                }
            }

            // remove any extra elements from the formatted list
            if (formattedItems.length > input.length) {
                formattedItems.splice(input.length, formattedItems.length - input.length);
            }
        }

        computeFilteredItems(scope: IGridScope) {
            scope.filterByDisplayFields = {};
            if (scope.gridOptions.filterByFields) {
                for (var fieldName in scope.gridOptions.filterByFields) {
                    scope.filterByDisplayFields[this.getFormattedFieldName(fieldName)] = scope.gridOptions.filterByFields[fieldName];
                }
            }
            debugMode && log("filtering items of length " + (scope.formattedItems ? scope.formattedItems.length : 0));
            scope.filteredItems = scope.$eval("formattedItems | filter:gridOptions.filterBy | filter:filterByDisplayFields | orderBy:'$$_gridItem.'+gridOptions.orderBy:gridOptions.orderByReverse | " + dataPagingFilter + ":gridOptions");
        }

        setupDisplayItemsArray(scope: IGridScope) {
            var watchExpression = "[gridOptions.items,gridOptions.gridColumnDefs.length";
            angular.forEach(this.gridOptions.gridColumnDefs, (gridColumnDef: IGridColumnOptions) => {
                if (gridColumnDef.displayFormat && gridColumnDef.displayFormat[0] != '.') {
                    // watch the parameters
                    var displayfilters = gridColumnDef.displayFormat.split('|');
                    angular.forEach(displayfilters, (displayFilter: string) => {
                        var displayFilterParams = displayFilter.split(':');
                        if (displayFilterParams.length > 1) {
                            angular.forEach(displayFilterParams.slice(1), (displayFilterParam: string) => {
                                displayFilterParam = displayFilterParam.trim();
                                if (displayFilterParam) {
                                    watchExpression += "," + displayFilterParam;
                                }
                            });
                        }
                    });
                }
            });

            watchExpression += "]";
            debugMode && log("re-formatting is set to watch for changes in "+watchExpression);
            scope.$watch(watchExpression, () => this.computeFormattedItems(scope), true);

            if (!scope.gridOptions.onDataRequired) {
                watchExpression = "["
                    + "requiresReFilteringTrigger, gridOptions.filterBy, gridOptions.filterByFields, gridOptions.orderBy, gridOptions.orderByReverse, gridOptions.currentPage"
                    + "]"; 
                scope.$watch(watchExpression, (newValue: Array<any>, oldValue: Array<any>) => {
                    this.computeFilteredItems(scope);
                }, true);
            }
        }

        linkAttrs(tAttrs: ng.IAttributes, localStorage: any) {
            var propSetter = (propName: string, propValue: any) => {                
                if (typeof (propValue) === "undefined")
                    return;

                switch (propValue) {
                    case "true":
                        propValue = true;
                        break;
                    case "false":
                        propValue = false;
                        break;
                }
                localStorage[propName] = propValue;
            }

            for (var propName in localStorage) {
                propSetter(propName, tAttrs[propName]);

                // watch for changes
                ((propName: string) => {
                    tAttrs.$observe(propName, (value: any) => propSetter(propName, value));
                })(propName);
            }
        }

        linkScope(internalScope:ng.IScope, externalScope:ng.IScope, scopeTargetIdentifier:string, attrs:ng.IAttributes){
            // this method shouldn't even be here
            // but it is because we want to allow people to either set attributes with either a constant or a watchable variable

            // watch for a resolution to issue #5951 on angular
            // https://github.com/angular/angular.js/issues/5951

            var target = internalScope[scopeTargetIdentifier];

            for (var propName in target) {
                var attributeExists = typeof (attrs[propName]) != "undefined" && attrs[propName] != null;

                if (attributeExists) {
                    var isArray = false;

                    // initialise from the scope first
                    if (typeof (externalScope[propName]) != "undefined" && externalScope[propName] != null) {
                        target[propName] = externalScope[propName];
                        isArray = target[propName] instanceof Array;
                    }

                    //allow arrays to be changed: if(!isArray){
                    var compiledAttrGetter: ng.ICompiledExpression = null;
                    try {
                        compiledAttrGetter = this.$parse(attrs[propName]);
                    }
                    catch (ex) {
                        // angular fails to parse literal bindings '@', thanks angular team
                    }
                    ((propName: string, compiledAttrGetter: ng.ICompiledExpression) => {
                        if (!compiledAttrGetter || !compiledAttrGetter.constant) {
                            // watch for a change in value and set it on our internal scope
                            externalScope.$watch(propName, (newValue: any, oldValue: any) => {
                                // debugMode && this.log("Property '" + propName + "' changed on the external scope from " + oldValue + " to " + newValue + ". Mirroring the parameter's value on the grid's internal scope.");
                                target[propName] = newValue;
                            });
                        }

                        var compiledAttrSetter: (context: any, value: any) => any = (compiledAttrGetter && compiledAttrGetter.assign) ? compiledAttrGetter.assign : null;
                        if (compiledAttrSetter) {
                            // a setter exists for the property, which means it's safe to mirror the internal prop on the external scope
                            internalScope.$watch(scopeTargetIdentifier + "." + propName, (newValue: any, oldValue: any) => {
                                try {
                                    // debugMode && this.log("Property '" + propName + "' changed on the internal scope from " + oldValue + " to " + newValue + ". Mirroring the parameter's value on the external scope.");
                                    externalScope[propName] = newValue;
                                    // Update: Don't do this, as you'll never hit the real scope the property was defined on
                                    // compiledAttrSetter(externalScope, newValue);
                                }
                                catch (ex) {
                                    if (debugMode) {
                                        log("Mirroring the property on the external scope failed with " + ex);
                                        throw ex;
                                    }
                                }
                            });
                        }
                    })(propName, compiledAttrGetter);
                }
            }
        }

    }

    var log = (message: string) => {
        console.log(tableDirective + "(" + new Date().getTime() + "): " + message);
    }

    var fixTableRowCellStructure = (
        sectionTag: string,
        rowElement: ng.IAugmentedJQuery,
        cellTag:string,
        cellDirectiveAttribute: string,
        cellTemplateDirectiveAttribute: string,
        cellAutoGeneratedDirectiveAttribute:string,
        rowCellDecoratorFct?: (cellElement: ng.IAugmentedJQuery) => void) => {

        // make sure the cell structure is in place
        var standardCellElement: ng.IAugmentedJQuery;

        angular.forEach(findChildrenByTagName(rowElement, cellTag), (existingCellElement: ng.IAugmentedJQuery) => {
            if (existingCellElement.attr(cellAutoGeneratedDirectiveAttribute)) {
                // our own auto-generated cell
                standardCellElement = existingCellElement;
            }
            else {
                // a cell template with options, customized or not
                var isCellCustomized = (existingCellElement.children().length > 0);

                // wrap the contents in a div, better now than later
                var cellContentsWrapperElement = angular.element("<div></div>");
                cellContentsWrapperElement.attr(cellTemplateDirectiveAttribute, "");
                if (isCellCustomized) {
                    cellContentsWrapperElement.attr(isCustomizedAttribute, "true");
                }

                var cellContents = existingCellElement.children();
                existingCellElement.empty();
                cellContentsWrapperElement.append(cellContents);

                existingCellElement.append(cellContentsWrapperElement);
            }

            existingCellElement.attr(cellDirectiveAttribute, "");
        });

        if (!standardCellElement) {
            // inject our cell element as well
            // but first, get through the pain of constructing one (thanks angular for the wonderful jqLite)
            standardCellElement =
                findChildByTagName(
                    findChildByTagName(
                        findChildByTagName(
                            angular.element("<table><" + sectionTag + "><tr><" + cellTag + "></" + cellTag + "></tr></" + sectionTag + "></table>"),
                            sectionTag),
                        "tr"),
                    cellTag);
            standardCellElement.attr(cellAutoGeneratedDirectiveAttribute, "");

            var cellContentsWrapperElement = angular.element("<div>{{$index}}</div>");
            cellContentsWrapperElement.attr(cellTemplateDirectiveAttribute, "");

            rowElement.prepend(standardCellElement);
            standardCellElement.append(cellContentsWrapperElement);
        }

        if (rowCellDecoratorFct) {
            rowCellDecoratorFct(standardCellElement);
        }
    }; 

    var fixTableSectionRowStructure = (
        sectionElement: ng.IAugmentedJQuery,
        sectionRowDecoratorFct: (rowElement: ng.IAugmentedJQuery, isFirst: boolean, isLast: boolean)=> void) => {

        // make sure the row element is present
        var sectionElementTag = sectionElement[0].tagName;
        var sectionRowElement = findChildByTagName(sectionElement, "tr");
        if (!sectionRowElement) {
            // work around an angular limitation
            sectionRowElement = findChildByTagName(findChildByTagName(angular.element("<table><" + sectionElementTag + "><tr></tr></" + sectionElementTag + "></table>"), sectionElementTag), "tr");
            sectionElement.append(sectionRowElement);
        }

        if (sectionRowDecoratorFct) {
            var sectionRowElements = findChildrenByTagName(sectionElement, "tr");
            angular.forEach(sectionRowElements, (sectionRowElement: ng.IAugmentedJQuery, index: number) => {
                sectionRowDecoratorFct(sectionRowElement, index === 0, index === sectionRowElements.length - 1);
            });
        }
    };

    var fixTableSectionStructure = (
        gridElement: ng.IAugmentedJQuery,
        sectionTag: string,
        tableSectionDecoratorFct: (sectionElement: ng.IAugmentedJQuery)=> void) => {

        // make sure the section element is present
        var tableSectionElement = findChildByTagName(gridElement, sectionTag);
        if (!tableSectionElement) {
            // work around an angular limitation
            tableSectionElement = findChildByTagName(angular.element("<table><" + sectionTag + "></" + sectionTag + "></table>"), sectionTag);
        }
        else {
            // in order to maintain the order of section elements, we'll have to remove it and re-insert it in the right place
            tableSectionElement.remove();
        }
        gridElement.prepend(tableSectionElement);

        // stop it from being compiled by angular, this will happen later
        tableSectionElement.attr("data-ng-non-bindable", "");

        if (tableSectionDecoratorFct) {
            tableSectionDecoratorFct(tableSectionElement);
        }
    };

    var fixTableStructure = (gridElement: ng.IAugmentedJQuery) => {
        gridElement.addClass(tableCssClass);

        // the order of sections in an HTML table is : header, footer, body

        // deal with the body
        fixTableSectionStructure(gridElement, "tbody", sectionElement => {
            sectionElement.attr(bodyDirectiveAttribute, "");
            fixTableSectionRowStructure(sectionElement, (rowElement, isFirst, isLast) => {
                if (isFirst) {
                    rowElement.attr("data-ng-repeat-start", "gridDisplayItem in filteredItems");
                    fixTableRowCellStructure(
                        "tbody",
                        rowElement,
                        "td",
                        cellBodyDirectiveAttribute,
                        cellBodyTemplateDirectiveAttribute,
                        cellBodyAutoGeneratedDirectiveAttribute,
                        (standardCellElement) => {
                            standardCellElement.attr("data-ng-repeat", "columnOptions in displayedGridColumnDefs");
                        });
                }
                if (isLast) {
                    rowElement.attr("data-ng-repeat-end", "");
                }
            });
        });

        // deal with the footer
        fixTableSectionStructure(gridElement, "tfoot", sectionElement => {
            sectionElement.attr(footerDirectiveAttribute, "");
            fixTableSectionRowStructure(sectionElement, (rowElement, isFirst, isLast) => {
                if (isLast) {
                    fixTableRowCellStructure(
                        "tfoot",
                        rowElement,
                        "td",
                        cellFooterDirectiveAttribute,
                        cellFooterTemplateDirectiveAttribute,
                        cellFooterAutoGeneratedDirectiveAttribute,
                        (standardCellElement) => {
                            standardCellElement.attr("data-ng-attr-colspan", "{{displayedGridColumnDefs.length}}");
                        });
                }
            });
        });

        // deal with the header
        fixTableSectionStructure(gridElement, "thead", sectionElement => {
            sectionElement.attr(headerDirectiveAttribute, "");
            fixTableSectionRowStructure(sectionElement, (rowElement, isFirst, isLast) => {
                if (isFirst) {
                    fixTableRowCellStructure(
                        "thead",
                        rowElement,
                        "th",
                        cellHeaderDirectiveAttribute,
                        cellHeaderTemplateDirectiveAttribute,
                        cellHeaderAutoGeneratedDirectiveAttribute,
                        (standardCellElement) => {
                            standardCellElement.attr("data-ng-repeat", "columnOptions in displayedGridColumnDefs");
                        });
                }
            });
        });

        console.log(gridElement[0].outerHTML);
    }

    angular.module("trNgGrid", [])
        .directive(tableDirective, ["$compile",
            ($compile: ng.ICompileService) => {
                return {
                    restrict: 'A',
                    scope: {
                        items: '=',
                        selectedItems: '=?',
                        filterBy: '=?',
                        filterByFields: '=?',
                        orderBy: '=?',
                        orderByReverse: '=?',
                        pageItems: '=?',
                        currentPage: '=?',
                        totalItems: '=?',
                        enableFiltering: '=?',
                        enableSorting: '=?',
                        selectionMode: '@',
                        locale: '@',
                        onDataRequired: '&',
                        onDataRequiredDelay: '=?',
                        fields: '=?'
                    },
                    controller: ["$compile", "$parse", "$timeout", "$templateCache", GridController],
                    template: (templateElement: ng.IAugmentedJQuery, tAttrs: Object) => {
                        fixTableStructure(templateElement);
                    },
                    compile: (templateElement: ng.IAugmentedJQuery, tAttrs: Object) => {

                        return (isolatedScope: ng.IScope, instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes, controller: GridController, transcludeFn: ng.ITranscludeFunction) => {
                            // we want to grab the settings, but we don't want to live in an isolated scope from this point onwards
                            // the original table template may contain a combination of both grid settings, outer bindings and templates which are linked to inner functionality
                            // a transcluded scope wouldn't work either, since that will put us straight outside
                            // hence we need to escape from the isolated scope or transclusions, and create a child scope of our own

                            // create our own child scope 
                            var gridScope = <IGridScope>isolatedScope.$parent.$new();

                            // grab all the settings and dual link them
                            controller.setupScope(isolatedScope, gridScope, tAttrs);
                            gridScope.speedUpAsyncDataRetrieval = ($event) => controller.speedUpAsyncDataRetrieval($event);
                            controller.setupDisplayItemsArray(gridScope);
                            controller.initializeColumnDefinitions(gridScope);

                            // controlled compilation
                            var headElement = findChildByTagName(instanceElement, "thead");
                            headElement.removeAttr("data-ng-non-bindable");
                            headElement.replaceWith($compile(headElement)(gridScope));

                            var footElement = findChildByTagName(instanceElement, "tfoot");
                            footElement.removeAttr("data-ng-non-bindable");
                            footElement.replaceWith($compile(footElement)(gridScope));

                            var bodyElement = findChildByTagName(instanceElement, "tbody");
                            bodyElement.removeAttr("data-ng-non-bindable");
                            bodyElement.replaceWith($compile(bodyElement)(gridScope));
                        }
                    }
                };
            }])
        .directive(cellHeaderAutoGeneratedDirective, [
            () => {
                return <ng.IDirective>{
                    restrict: 'A',
                    scope: false,
                    require: '^' + tableDirective,
                    compile: (instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes) => {
                        return {
                            pre: (gridColumnScope: IGridColumnScope, instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes, controller: GridController, transcludeFn: ng.ITranscludeFunction) => {
                                if (!gridColumnScope.gridOptions) {
                                    debugger;
                                    throw new Error("Could not find the grid options");
                                }
                                gridColumnScope.columnOptions.ephemeralPlaceholder = instanceElement;
                            }
                        };
                    }
                };
            }
        ])
        .directive(cellHeaderDirective, [
            () => {
                return <ng.IDirective>{
                    restrict: 'A',
                    scope: {
                        fieldName: '@',
                        displayName: '=?',
                        displayAlign: '=?',
                        displayFormat: '=?',
                        enableSorting: '=?',
                        enableFiltering: '=?',
                        isCustomized: '=?',
                        cellWidth: '=?',
                        cellHeight: '=?',
                        filter: '=?',
                    },
                    require: '^' + tableDirective,
                    transclude: true,
                    // template: "<th>temp template</th>", // replaced by transclusion
                    compile: (instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes) => {
                        return (isolatedScope: IGridHeaderColumnSettingsScope, instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes, controller: GridController, transcludeFn: ng.ITranscludeFunction) => {
                            // prepare a scope of our own in order to escape the isolation later
                            var gridColumnScope = isolatedScope.$parent.$new();

                            var fieldName = isolatedScope.fieldName;
                            var isCustomized = isolatedScope.isCustomized || false;
                            var columnDefinition: IGridColumnDefinition;

                            // supress some of the local settings
                            isolatedScope = <IGridHeaderColumnSettingsScope>isolatedScope.$new();
                            isolatedScope.isCustomized = null;

                            // register the settings
                            columnDefinition = controller.registerColumn(fieldName, ColumnDefinitionSource.Header, isCustomized, isolatedScope);

                            //compile on our own grounds, escape the isolation
                            transcludeFn(gridColumnScope, (transcludedElement: ng.IAugmentedJQuery, gridColumnScope: IGridColumnScope) => {
                                gridColumnScope.columnOptions = columnDefinition;
                                instanceElement.remove();
                                columnDefinition.ephemeralPlaceholder.empty();
                                columnDefinition.ephemeralPlaceholder.append(transcludedElement);
                            });

                            isolatedScope.$on("destroy", () => {
                                debugger;
                                controller.unregisterColumn(fieldName, ColumnDefinitionSource.Header);
                            });
                        };
                    }
                };
            }
        ])
        .directive(cellHeaderTemplateDirective, [
            () => {
                var setupColumnTitle = (scope: IGridHeaderColumnScope) => {
                    if (scope.columnOptions.displayName) {
                        scope.columnTitle = scope.columnOptions.displayName;
                    }
                    else {
                        if (!scope.columnOptions.fieldName) {
                            scope.columnTitle = "[Invalid Field Name]";
                        }
                        else {
                            // exclude nested notations
                            var splitFieldName = scope.columnOptions.fieldName.match(/^[^\.\[\]]*/);

                            // split by camel-casing
                            splitFieldName = splitFieldName[0].split(/(?=[A-Z])/);
                            if (splitFieldName.length && splitFieldName[0].length) {
                                splitFieldName[0] = splitFieldName[0][0].toLocaleUpperCase() + splitFieldName[0].substr(1);
                            }
                            scope.columnTitle = splitFieldName.join(" ");
                        }
                    }
                };

                return {
                    restrict: 'A',
                    require: '^' + tableDirective,
                    templateUrl: cellHeaderTemplateId,
                    replace: true,
                    scope: true,
                    link: (gridColumnScope: IGridHeaderColumnScope, instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes, controller: GridController, transcludeFn: ng.ITranscludeFunction) => {
                        if (!gridColumnScope.gridOptions) {
                            debugger;
                            throw new Error("Could not find the grid options");
                        }

                        gridColumnScope.toggleSorting = (propertyName: string) => {
                            controller.toggleSorting(propertyName);
                        };

                        // set up the column title
                        setupColumnTitle(gridColumnScope);

                        // watch for changes in the column filter
                        gridColumnScope.$watch("columnOptions.filter", (newValue: string, oldValue: string) => {
                            if (newValue !== oldValue) {
                                controller.setFilter(gridColumnScope.columnOptions.fieldName, newValue);
                            }
                        });

                    }
                };
            }
        ])
        .directive(columnSortDirective, [
            function () {
                return {
                    restrict: 'A',
                    require: '^' + tableDirective,
                    replace: true,
                    templateUrl: columnSortTemplateId
                };
            }
        ])
        .directive(columnFilterDirective, [
            function () {
                return {
                    restrict: 'A',
                    require: '^' + tableDirective,
                    replace: true,
                    templateUrl: columnFilterTemplateId
                };
            }
        ])
        ////.directive(cellBodyTemplateDirective, [
        ////    () => {
        ////        return <ng.IDirective>{
        ////            restrict: 'A',
        ////            require: '^' + tableDirective,
        ////            templateUrl: cellBodyTemplateId,
        ////            replace: true,
        ////            scope: true,
        ////            link: (gridBodyCellScope: IGridBodyColumnScope, instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes, controller: GridController, transcludeFn: ng.ITranscludeFunction) => {
        ////            }
        ////        };
        ////    }
        ////])
        ////.directive(cellFooterDirective, [
        ////    () => {
        ////        return <ng.IDirective>{
        ////            restrict: 'A',
        ////            require: '^' + tableDirective,
        ////            template: '<div ' + cellFooterTemplateDirectiveAttribute + ' = ""></div>',
        ////        };
        ////    }
        ////])
        ////.directive(cellFooterTemplateDirective, [
        ////    () => {
        ////        return {
        ////            restrict: 'A',
        ////            require: '^' + tableDirective,
        ////            templateUrl: cellFooterTemplateId,
        ////            transclude: true,
        ////            replace: true
        ////        };
        ////    }
        ////])

        ////.directive(bodyDirective, [
        ////    () => {
        ////        return <ng.IDirective>{
        ////            restrict: 'A',
        ////            require: '^' + tableDirective,
        ////            template: '<tr ng-repeat="gridDisplayItem in filteredItems"><td>Test</td></tr>',
        ////            compile: (templateElement: ng.IAugmentedJQuery, templateAttributes: ng.IAttributes) => {
        ////                debugger;
        ////                return (gridScope: IGridScope, instanceElement: ng.IAugmentedJQuery, tAttrs: ng.IAttributes, controller: GridController, transcludeFn: ng.ITranscludeFunction) => {
        ////                    debugger;
        ////                }
        ////            }
        ////        }
        ////    }
        ////])
        ////.directive(cellHeaderDirective, [
        ////    () => {
        ////        var setupColumnTitle = (scope: IGridHeaderColumnScope) => {
        ////            if (scope.columnOptions.displayName) {
        ////                scope.columnTitle = scope.columnOptions.displayName;
        ////            }
        ////            else {
        ////                if (!scope.columnOptions.fieldName) {
        ////                    scope.columnTitle = "[Invalid Field Name]";
        ////                }
        ////                else {
        ////                    // exclude nested notations
        ////                    var splitFieldName = scope.columnOptions.fieldName.match(/^[^\.\[\]]*/);

        ////                    // split by camel-casing
        ////                    splitFieldName = splitFieldName[0].split(/(?=[A-Z])/);
        ////                    if (splitFieldName.length && splitFieldName[0].length) {
        ////                        splitFieldName[0] = splitFieldName[0][0].toLocaleUpperCase() + splitFieldName[0].substr(1);
        ////                    }
        ////                    scope.columnTitle = splitFieldName.join(" ");
        ////                }
        ////            }
        ////        };

        ////        return {
        ////            restrict: 'A',
        ////            require: '^' + tableDirective,
        ////            scope: true,
        ////            compile: (templateElement: JQuery, tAttrs: Object) => {
        ////                var isCustomized = tAttrs['isCustomized'] == 'true';
        ////                //wrapTemplatedCell(templateElement, tAttrs, isCustomized, cellHeaderTemplateDirectiveAttribute);

        ////                return {
        ////                    // we receive a reference to a real element that will appear in the DOM, after the controller was created, but before binding setup
        ////                    pre: (scope: IGridHeaderColumnScope, instanceElement: JQuery, tAttrs: ng.IAttributes, controller: GridController, $transclude: ng.ITranscludeFunction) => {
        ////                        // we're not interested in creating an isolated scope just to parse the element attributes,
        ////                        // so we're gonna have to do this manually

        ////                        var columnIndex = parseInt(tAttrs[cellHeaderDirective]);

        ////                        // create a clone of the default column options
        ////                        var columnOptions: IGridColumnOptions = angular.extend(scope.gridOptions.gridColumnDefs[columnIndex], defaultColumnOptions);

        ////                        // now match and observe the attributes
        ////                        controller.linkAttrs(tAttrs, columnOptions);

        ////                        // set up the new scope
        ////                        scope.columnOptions = columnOptions;
        ////                        scope.isCustomized = isCustomized;
        ////                        scope.toggleSorting = (propertyName: string) => {
        ////                            controller.toggleSorting(propertyName);
        ////                        };

        ////                        // set up the column title
        ////                        setupColumnTitle(scope);

        ////                        scope.$watch("columnOptions.filter", (newValue: string, oldValue: string) => {
        ////                            if (newValue !== oldValue) {
        ////                                controller.setFilter(columnOptions.fieldName, newValue);
        ////                            }
        ////                        });
        ////                    }
        ////                }
        ////            }
        ////        };
        ////    }
        ////])
        ////.directive(cellHeaderTemplateDirective, [
        ////    () => {
        ////        return {
        ////            restrict: 'A',
        ////            templateUrl: cellHeaderTemplateId,
        ////            transclude: true,
        ////            replace: true,
        ////        };
        ////    }
        ////])
        ////.directive(bodyDirective, [
        ////    () => {
        ////        return {
        ////            restrict: 'A',
        ////            require: '^' + tableDirective,
        ////            scope: true,
        ////            compile: (templateElement: JQuery, tAttrs: Object) => {
        ////                return {
        ////                    pre: function (scope: IGridBodyScope, compiledInstanceElement: JQuery, tAttrs: ng.IAttributes, controller: GridController) {
        ////                        scope.toggleItemSelection = (item: any, $event: ng.IAngularEvent) => {
        ////                            controller.toggleItemSelection(scope.filteredItems, item, $event);
        ////                        };
        ////                    }
        ////                }
        ////            }
        ////        };
        ////    }
        ////])
        ////    .directive(cellBodyDirective, [
        ////        () => {
        ////            return {
        ////                restrict: 'A',
        ////                require: '^' + tableDirective,
        ////                scope: true,
        ////                compile: (templateElement: JQuery, tAttrs: Object) => {
        ////                    var isCustomized = tAttrs['isCustomized'] == 'true';
        ////                    // wrapTemplatedCell(templateElement, tAttrs, isCustomized, cellBodyTemplateDirectiveAttribute);

        ////                    return {
        ////                        pre: (scope: IGridBodyColumnScope, instanceElement: JQuery, tAttrs: ng.IAttributes, controller: GridController, $transclude: ng.ITranscludeFunction) => {
        ////                            scope.columnOptions = scope.gridOptions.gridColumnDefs[parseInt(tAttrs[cellBodyDirective])];
        ////                            scope.gridItem = scope.gridDisplayItem.$$_gridItem;
        ////                            scope.isCustomized = isCustomized;
        ////                        }
        ////                    };
        ////                }
        ////            };
        ////        }
        ////    ])
        ////    .directive(cellBodyTemplateDirective, [
        ////        () => {
        ////            return {
        ////                restrict: 'A',
        ////                templateUrl: cellBodyTemplateId,
        ////                transclude: true,
        ////                replace: true
        ////            };
        ////        }
        ////    ])
        ////    .directive(cellFooterDirective, [
        ////        () => {
        ////            return {
        ////                restrict: 'A',
        ////                require: '^' + tableDirective,
        ////                scope: true,
        ////                compile: (templateElement: JQuery, tAttrs: Object) => {
        ////                    var isCustomized = tAttrs['isCustomized'] == 'true';
        ////                    // wrapTemplatedCell(templateElement, tAttrs, isCustomized, cellFooterTemplateDirectiveAttribute);

        ////                    return {
        ////                        pre: (scope: IGridFooterScope, instanceElement: JQuery, tAttrs: ng.IAttributes, controller: GridController, $transclude: ng.ITranscludeFunction) => {
        ////                            scope.isCustomized = isCustomized;
        ////                            instanceElement.attr("colspan", scope.gridOptions.gridColumnDefs.length);
        ////                        }
        ////                    };
        ////                }
        ////            };
        ////        }
        ////    ])
            .directive(globalFilterDirective, [
                function () {
                    return {
                        restrict: 'A',
                        scope: false,
                        templateUrl: footerGlobalFilterTemplateId,
                    };
                }
            ])
            .directive(pagerDirective, [
                function () {
                    var setupScope = (scope: IGridFooterScope, controller: GridController) => {

                        // do not set scope.gridOptions.totalItems, it might be set from the outside
                        scope.totalItemsCount = (typeof (scope.gridOptions.totalItems) != "undefined" && scope.gridOptions.totalItems != null)
                        ? scope.gridOptions.totalItems
                        : (scope.gridOptions.items ? scope.gridOptions.items.length : 0);

                        scope.isPaged = (!!scope.gridOptions.pageItems) && (scope.gridOptions.pageItems < scope.totalItemsCount);
                        scope.extendedControlsActive = false;

                        scope.startItemIndex = scope.isPaged ? (scope.gridOptions.pageItems * scope.gridOptions.currentPage) : 0;
                        scope.endItemIndex = scope.isPaged ? (scope.startItemIndex + scope.gridOptions.pageItems - 1) : scope.totalItemsCount - 1;
                        if (scope.endItemIndex >= scope.totalItemsCount) {
                            scope.endItemIndex = scope.totalItemsCount - 1;
                        }
                        if (scope.endItemIndex < scope.startItemIndex) {
                            scope.endItemIndex = scope.startItemIndex;
                        }
                        scope.lastPageIndex = (!scope.totalItemsCount || !scope.isPaged)
                        ? 0
                        : (Math.floor(scope.totalItemsCount / scope.gridOptions.pageItems) + ((scope.totalItemsCount % scope.gridOptions.pageItems) ? 0 : -1));

                        scope.pageCanGoBack = scope.isPaged && scope.gridOptions.currentPage > 0;
                        scope.pageCanGoForward = scope.isPaged && scope.gridOptions.currentPage < scope.lastPageIndex;

                        scope.pageIndexes = scope.pageIndexes || [];
                        scope.pageIndexes.splice(0);
                        if (scope.isPaged) {
                            if (scope.lastPageIndex + 1 > TrNgGrid.defaultPagerMinifiedPageCountThreshold) {
                                scope.extendedControlsActive = true;

                                var pageIndexHalfRange = Math.floor(TrNgGrid.defaultPagerMinifiedPageCountThreshold/2);
                                var lowPageIndex = scope.gridOptions.currentPage - pageIndexHalfRange;
                                var highPageIndex = scope.gridOptions.currentPage + pageIndexHalfRange;

                                // compute the high and low
                                if (lowPageIndex < 0) {
                                    highPageIndex += -lowPageIndex;
                                    lowPageIndex = 0;
                                }
                                else if (highPageIndex > scope.lastPageIndex) {
                                    lowPageIndex -= highPageIndex - scope.lastPageIndex;
                                    highPageIndex = scope.lastPageIndex;
                                }

                                // add the extra controls where needed
                                if (lowPageIndex > 0) {
                                    scope.pageIndexes.push(null);
                                    lowPageIndex++;
                                }
                                var highPageEllipsed = false;
                                if (highPageIndex < scope.lastPageIndex) {
                                    highPageEllipsed = true;
                                    highPageIndex--;
                                }

                                for (var pageIndex = lowPageIndex; pageIndex <= highPageIndex; pageIndex++) {
                                    scope.pageIndexes.push(pageIndex);
                                }

                                if (highPageEllipsed) {
                                    scope.pageIndexes.push(null);
                                }
                            }
                            else {
                                scope.extendedControlsActive = false;
                                // we can display all of them
                                for (var pageIndex = 0; pageIndex <= scope.lastPageIndex; pageIndex++) {
                                    scope.pageIndexes.push(pageIndex);
                                }
                            }
                        }
                        scope.pageSelectionActive = scope.pageIndexes.length > 1;

                        scope.navigateToPage = (pageIndex) => {
                            scope.gridOptions.currentPage = pageIndex;
                            scope.speedUpAsyncDataRetrieval();
                            /*$event.preventDefault();
                            $event.stopPropagation();*/
                        }

                        scope.switchPageSelection = ($event, pageSelectionActive) => {
                            scope.pageSelectionActive = pageSelectionActive;
                            if ($event) {
                                $event.preventDefault();
                                $event.stopPropagation();
                            }
                        }
                    };

                    //ng - model = "gridOptions.currentPage" 

                    return {
                        restrict: 'A',
                        scope: true,
                        require: '^' + tableDirective,
                        templateUrl: footerPagerTemplateId,
                        replace: true,
                        compile: (templateElement: JQuery, tAttrs: Object) => {
                            debugger;
                            return {
                                pre: function (scope: IGridFooterScope, compiledInstanceElement: JQuery, tAttrs: ng.IAttributes, controller: GridController) {
                                    setupScope(scope, controller);
                                },
                                post: function (scope: IGridFooterScope, instanceElement: JQuery, tAttrs: ng.IAttributes, controller: GridController) {
                                    scope.$watchCollection("[gridOptions.currentPage, gridOptions.items.length, gridOptions.totalItems, gridOptions.pageItems]", (newValues: Array<any>, oldValues: Array<any>) => {
                                        setupScope(scope, controller);
                                    });
                                }
                            };
                        }
                    };
                }
            ])
        /*.filter("testFilter", () => {
            return (input: Array<any>) => {
                debugger;
            };
        })*/
            .filter(dataPagingFilter, () => {
                // when server-side logic is enabled, this directive should not be used!
                return (input: Array<any>, gridOptions: IGridOptions) => {
                    //currentPage?:number, pageItems?:number
                    if (input)
                        gridOptions.totalItems = input.length;

                    if (!gridOptions.pageItems || !input || input.length == 0)
                        return input;

                    if (!gridOptions.currentPage) {
                        gridOptions.currentPage = 0;
                    }

                    var startIndex = gridOptions.currentPage * gridOptions.pageItems;
                    if (startIndex >= input.length) {
                        gridOptions.currentPage = 0;
                        startIndex = 0;
                    }
                    var endIndex = gridOptions.currentPage * gridOptions.pageItems + gridOptions.pageItems;

                    return input.slice(startIndex, endIndex);
                };
            })
        .filter(translateFilter, ["$filter", ($filter: ng.IFilterService) => {
            return (input: any, languageId: string) => {
                var translatedText: string;

                // dates require special attention
                if (input instanceof Date) {
                    // we're dealing with a date object, see if we have a localized format for it
                    var dateFormat = $filter(translateFilter)(TrNgGrid.translationDateFormat, languageId);
                    if (dateFormat && dateFormat !== TrNgGrid.translationDateFormat) {
                        // call the date filter
                        translatedText = $filter("date")(input, dateFormat);
                        return translatedText;
                    }
                    return input;
                }

                if (!translatedText) {
                    var languageIdParts = languageId.split(/[-_]/);
                    for (var languageIdPartIndex = languageIdParts.length; (languageIdPartIndex > 0) && (!translatedText); languageIdPartIndex--) {
                        var subLanguageId = languageIdParts.slice(0, languageIdPartIndex).join("-");
                        var langTranslations = translations[subLanguageId];
                        if (langTranslations) {
                            translatedText = langTranslations[input];
                        }
                    }
                }

                if (!translatedText) {
                    // check for a filter directive
                    try {
                        var externalTranslationFilter = $filter("translate");
                        if (externalTranslationFilter) {
                            translatedText = externalTranslationFilter(input);
                        }
                    }
                    catch (ex) {
                    }
                }

                if (!translatedText) {
                    translatedText = input;
                }

                return translatedText;
            };
        }])
        .run(function () {
            TrNgGrid.tableCssClass = "tr-ng-grid table table-bordered table-hover"; // at the time of coding, table-striped is not working properly with selection
            TrNgGrid.cellCssClass = "tr-ng-cell";
            TrNgGrid.headerCellCssClass = "tr-ng-column-header " + TrNgGrid.cellCssClass;
            TrNgGrid.bodyCellCssClass = cellCssClass;
            TrNgGrid.columnTitleCssClass = "tr-ng-title";
            TrNgGrid.columnSortCssClass = "tr-ng-sort";
            TrNgGrid.columnFilterCssClass = "tr-ng-column-filter";
            TrNgGrid.columnFilterInputWrapperCssClass = "";
            TrNgGrid.columnSortActiveCssClass = "tr-ng-sort-active text-info";
            TrNgGrid.columnSortInactiveCssClass = "tr-ng-sort-inactive text-muted glyphicon glyphicon-chevron-down";
            TrNgGrid.columnSortReverseOrderCssClass = "tr-ng-sort-order-reverse glyphicon glyphicon-chevron-down";
            TrNgGrid.columnSortNormalOrderCssClass = "tr-ng-sort-order-normal glyphicon glyphicon-chevron-up";
            TrNgGrid.rowSelectedCssClass = "active";
            TrNgGrid.footerCssClass = "tr-ng-grid-footer form-inline";
        })
        .run(function () {
            TrNgGrid.defaultColumnOptions.displayAlign = 'left';
            TrNgGrid.defaultPagerMinifiedPageCountThreshold = 3;
        });

    function configureTemplates($templateCache: ng.ITemplateCacheService) {
        // set up default templates
        if (!$templateCache.get(TrNgGrid.cellHeaderTemplateId)) {
            $templateCache.put(TrNgGrid.cellHeaderTemplateId,
                '<div class="' + TrNgGrid.headerCellCssClass + '" ng-switch="columnOptions.isCustomized">'
                + '  <div ng-switch-when="true">'
                + '    <div ng-transclude=""></div>'
                + '  </div>'
                + '  <div ng-switch-default>'
                + '    <div class="' + TrNgGrid.columnTitleCssClass + '">'
                + '      {{columnTitle |' + TrNgGrid.translateFilter + ':gridOptions.locale}}'
                + '       <div ' + TrNgGrid.columnSortDirectiveAttribute + '=""></div>'
                + '    </div>'
                + '    <div ' + TrNgGrid.columnFilterDirectiveAttribute + '=""></div>'
                + '  </div>'
                + '</div>'
                );
        }
        if (!$templateCache.get(TrNgGrid.cellBodyTemplateId)) {
            $templateCache.put(TrNgGrid.cellBodyTemplateId,
                '<div ng-attr-class="' + TrNgGrid.bodyCellCssClass + ' text-{{columnOptions.displayAlign}}" ng-switch="columnOptions.isCustomized">'
                + '  <div ng-switch-when="true">'
                + '    <div ng-transclude=""></div>'
                + '  </div>'
                + '  <div ng-switch-default>{{gridDisplayItem[columnOptions.displayFieldName]}}</div>'
                + '</div>'
                );
        }
        if (!$templateCache.get(TrNgGrid.columnFilterTemplateId)) {
            $templateCache.put(TrNgGrid.columnFilterTemplateId,
                '<div ng-show="(gridOptions.enableFiltering&&columnOptions.enableFiltering!==false)||columnOptions.enableFiltering" class="' + TrNgGrid.columnFilterCssClass + '">'
                + ' <div class="' + TrNgGrid.columnFilterInputWrapperCssClass + '">'
                + '   <input class="form-control input-sm" type="text" ng-model="columnOptions.filter" ng-keypress="speedUpAsyncDataRetrieval($event)"></input>'
                + ' </div>'
                + '</div>');
        }
        if (!$templateCache.get(TrNgGrid.columnSortTemplateId)) {
            $templateCache.put(TrNgGrid.columnSortTemplateId,
                '<div ng-attr-title="{{\'Sort\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}"'
                + ' ng-show="(gridOptions.enableSorting&&columnOptions.enableSorting!==false)||columnOptions.enableSorting"'
                + ' ng-click="toggleSorting(columnOptions.fieldName)"'
                + ' class="' + TrNgGrid.columnSortCssClass + '" > '
                + '  <div ng-class="{\''
                + TrNgGrid.columnSortActiveCssClass + '\':gridOptions.orderBy==columnOptions.fieldName,\''
                + TrNgGrid.columnSortInactiveCssClass + '\':gridOptions.orderBy!=columnOptions.fieldName,\''
                + TrNgGrid.columnSortNormalOrderCssClass + '\':gridOptions.orderBy==columnOptions.fieldName&&!gridOptions.orderByReverse,\''
                + TrNgGrid.columnSortReverseOrderCssClass + '\':gridOptions.orderBy==columnOptions.fieldName&&gridOptions.orderByReverse}" >'
                + '  </div>'
                + '</div>');
        }
        if (!$templateCache.put(TrNgGrid.cellFooterTemplateId)) {
            $templateCache.put(TrNgGrid.cellFooterTemplateId,
                '<div class="' + TrNgGrid.footerCssClass + '" ng-switch="isCustomized">'
                + '  <div ng-switch-when="true">'
                + '    <div ng-transclude=""></div>'
                + '  </div>'
                + '  <div ng-switch-default>'
                + '    <span ' + TrNgGrid.globalFilterDirectiveAttribute + '=""></span>'
                + '    <span ' + TrNgGrid.pagerDirectiveAttribute + '=""></span>'
                + '  </div>'
                + '</div>');
        }
        if (!$templateCache.get(TrNgGrid.footerGlobalFilterTemplateId)) {
            $templateCache.put(TrNgGrid.footerGlobalFilterTemplateId,
                '<span ng-show="gridOptions.enableFiltering" class="pull-left form-group">'
                + '  <input class="form-control" type="text" ng-model="gridOptions.filterBy" ng-keypress="speedUpAsyncDataRetrieval($event)" ng-attr-placeholder="{{\'Search\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}"></input>'
                + '</span>');
        }
        if (!$templateCache.get(TrNgGrid.footerPagerTemplateId)) {
            $templateCache.put(TrNgGrid.footerPagerTemplateId,
                '<span class="pull-right form-group">'
                + ' <ul class="pagination">'
                + '   <li ng-class="{disabled:!pageCanGoBack}" ng-if="extendedControlsActive">'
                + '     <a href="" ng-click="pageCanGoBack&&navigateToPage(0)" ng-attr-title="{{\'First Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
                //+ '         <span class="glyphicon glyphicon-fast-backward"></span>' 
                + '         <span>&laquo;</span>' 
                + '     </a>'
                + '   </li>'
                + '   <li ng-class="{disabled:!pageCanGoBack}" ng-if="extendedControlsActive">'
                + '     <a href="" ng-click="pageCanGoBack&&navigateToPage(gridOptions.currentPage - 1)" ng-attr-title="{{\'Previous Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
                //+ '         <span class="glyphicon glyphicon-step-backward"></span>' 
                + '         <span>&lsaquo;</span>' 
                + '     </a>'
                + '   </li>'
                + '   <li ng-if="pageSelectionActive" ng-repeat="pageIndex in pageIndexes track by $index" ng-class="{disabled:pageIndex===null, active:pageIndex===gridOptions.currentPage}">'
                + '      <span ng-if="pageIndex===null">...</span>'
                + '      <a href="" ng-click="navigateToPage(pageIndex)" ng-if="pageIndex!==null" ng-attr-title="{{\'Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">{{pageIndex+1}}</a>'
                + '   </li>'
                + '   <li ng-class="{disabled:!pageCanGoForward}" ng-if="extendedControlsActive">'
                + '     <a href="" ng-click="pageCanGoForward&&navigateToPage(gridOptions.currentPage + 1)" ng-attr-title="{{\'Next Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
                //+ '         <span class="glyphicon glyphicon-step-forward"></span>' 
                + '         <span>&rsaquo;</span>' 
                + '     </a>'
                + '   </li>'
                + '   <li ng-class="{disabled:!pageCanGoForward}" ng-if="extendedControlsActive">'
                + '     <a href="" ng-click="pageCanGoForward&&navigateToPage(lastPageIndex)" ng-attr-title="{{\'Last Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
                //+ '         <span class="glyphicon glyphicon-fast-forward"></span>' 
                + '         <span>&raquo;</span>' 
                + '     </a>'
                + '   </li>'
                + '   <li class="disabled" style="white-space: nowrap;">'
                + '     <span ng-hide="totalItemsCount">{{\'No items to display\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}</span>'
                + '     <span ng-show="totalItemsCount" ng-attr-title="{{\'Select Page\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}">'
                + '       {{startItemIndex+1}} - {{endItemIndex+1}} {{\'displayed\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}'
                + '       <span>, {{totalItemsCount}} {{\'in total\'|' + TrNgGrid.translateFilter + ':gridOptions.locale}}</span>'
                + '     </span > '
                + '   </li>'
                + ' </ul>'
                + '</span>');
        }
    }
}